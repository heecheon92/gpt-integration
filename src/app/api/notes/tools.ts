import {
  EMBEDDING_FILTER_TAG_KEY,
  EMBEDDING_NOTES_FILTER_TAG,
} from "@/constants";
import { gptIndex } from "@/lib/db/pinecone";
import { prisma } from "@/lib/db/prisma";
import { tool } from "ai";
import { toZonedTime } from "date-fns-tz/toZonedTime";
import { endOfDay } from "date-fns/endOfDay";
import { startOfDay } from "date-fns/startOfDay";
import { z } from "zod";
import { createNote } from "./util";

export function noteTools({
  userId,
  embedding,
  timezone,
}: {
  userId: string;
  embedding: number[];
  timezone?: string | null;
}) {
  return {
    getNotes: tool({
      description: "Get the notes for the user",
      parameters: z.object({
        daterange: z
          .object({
            from: z.string().datetime(),
            to: z.string().datetime(),
          })
          .optional(),
      }),
      execute: async ({ daterange }) => {
        console.log(
          "getNotes tool called with daterange: ",
          JSON.stringify(daterange, null, 2),
        );

        try {
          const queryFilter = {
            userId,
            [EMBEDDING_FILTER_TAG_KEY]: EMBEDDING_NOTES_FILTER_TAG,
          };
          const vectorQueryResponse = await gptIndex.query({
            vector: embedding,
            topK: 20,
            filter: queryFilter,
          });
          const relevantNotes = await prisma.note.findMany({
            where: {
              id: {
                in: vectorQueryResponse.matches.map((match) => match.id),
              },
              OR: [
                {
                  createdAt: daterange
                    ? {
                        gte: daterange.from,
                        lte: daterange.to,
                      }
                    : undefined,
                },
                {
                  updatedAt: daterange
                    ? {
                        gte: daterange.from,
                        lte: daterange.to,
                      }
                    : undefined,
                },
              ],
            },
          });

          return relevantNotes
            .map((note) => `Title: ${note.title}\n\nContent: ${note.content}`)
            .join("\n\n");
        } catch (error) {
          console.error(error);
          return "An error occurred while fetching the notes. Please try again.";
        }
      },
    }),
    makeNote: tool({
      description: "Create a note based on user's request",
      parameters: z.object({
        title: z.string(),
        content: z.string(),
      }),
      execute: async ({ title, content }) => {
        console.log("makeNote tool called");
        try {
          const note = await createNote({ userId, title, content });
          return `Note created successfully with title: ${note.title} and content: ${note.content}`;
        } catch (error) {
          console.error(error);
          return "An error occurred while creating the note. Please try again.";
        }
      },
    }),
    askForConfirmation: tool({
      description: "Ask the user for confirmation to create the note.",
      parameters: z.object({
        message: z
          .string()
          .describe(
            "The message to ask for confirmation with summary of the note including the title and content.",
          ),
      }),
    }),
    promptForNoteData: tool({
      description: "Prompt the user to provide the note data.",
      parameters: z.object({
        message: z
          .string()
          .describe(
            "The message to prompt the user to provide the note data.\n" +
              "If title is missing, ask for the title.\n" +
              "If content is missing, ask for the content.\n" +
              "If both are missing, ask for both.",
          ),
        title: z
          .string()
          .optional()
          .describe("The title of the note, if generated by the user"),
        content: z
          .string()
          .optional()
          .describe("The content of the note, if generated by the user"),
        titleLabel: z
          .string()
          .optional()
          .describe(
            "The label for the title, required if user has not provided the title",
          ),
        contentLabel: z
          .string()
          .optional()
          .describe(
            "The label for the content, required if user has not provided the content",
          ),
        createButtonLabel: z
          .string()
          .describe("The label for the create button"),
        cancelButtonLabel: z
          .string()
          .describe("The label for the cancel button"),
      }),
    }),
    getUserDatetime: tool({
      description: "Get the current datetime",
      parameters: z.object({}),
      execute: async () => {
        const now = new Date();
        if (!timezone) {
          return {
            from: startOfDay(now).toISOString(),
            to: endOfDay(now).toISOString(),
          };
        }

        return {
          from: startOfDay(toZonedTime(now, timezone)).toISOString(),
          to: endOfDay(toZonedTime(now, timezone)).toISOString(),
        };
      },
    }),
  };
}
